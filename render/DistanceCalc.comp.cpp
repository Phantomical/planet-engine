const char* DistanceCalc = 
"#version 430\n"
"\n"
"// This shader calculates the distance \n"
"// of each vertex from the local origin\n"
"\n"
"#define SIDE_LEN 129\n"
"\n"
"layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\n"
"\n"
"struct VertexInput\n"
"{\n"
"	vec4 vtx_start;\n"
"	float _u1;\n"
"	float _u2;\n"
"	float _u3;\n"
"};\n"
"\n"
"layout(binding = 0, packed) buffer verts_input\n"
"{\n"
"	VertexInput inputs[];\n"
"};\n"
"\n"
"layout(binding = 1, std430) buffer results\n"
"{\n"
"	float result;\n"
"};\n"
"\n"
"shared float values[SIDE_LEN * ((SIDE_LEN + 15) / 16)];\n"
"\n"
"layout(location = 2) uniform uvec2 size_vec;\n"
"\n"
"#define vertex vtx_start.xyz\n"
"\n"
"void main()\n"
"{\n"
"	const uvec2 size_vec = uvec2(SIDE_LEN, ((SIDE_LEN + 15) / 16));\n"
"\n"
"	// Get the index into the values array\n"
"	uint index = gl_GlobalInvocationID.x * size_vec.x + gl_GlobalInvocationID.y;\n"
"	uint size = size_vec.x * size_vec.y;\n"
"	\n"
"	float val = -1.0;\n"
"	for (uint i = 0; i < 16 && index * 4 + 1 < size; ++i)\n"
"		val = max(val, length(inputs[index * 4 + i].vertex));\n"
"\n"
"	values[index] = val;\n"
"\n"
"	barrier();\n"
"\n"
"	for (uint s = values.length() >> 1; s > 0; s >>= 1)\n"
"	{\n"
"		if (index < s - 1)\n"
"		{\n"
"			values[index] = max(values[index], values[index + s]);\n"
"		}\n"
"		else if (index < s)\n"
"		{\n"
"			if ((index & 1) == 0)\n"
"				values[index] = max(values[index], values[index + s]);\n"
"			// We don't need to do anything if s is odd\n"
"			// since this is the last element there is\n"
"			// no other element to compare against\n"
"		}\n"
"\n"
"		barrier();\n"
"	}\n"
"\n"
"	if (index == 0)\n"
"	{\n"
"		result = values[0];\n"
"	}\n"
"}\n"
;

